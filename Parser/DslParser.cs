#if FULL_VERSION
// DslParser.cs - generated by the SLK parser generator 

namespace Dsl.Parser
{

    class DslParser
    {

        private static short[] Production = {0

,2,34,35 ,3,35,36,80 ,3,36,53,105 ,3,37,54,105 ,3,38,55,105 
,3,39,56,105 ,3,40,57,105 ,3,41,58,105 ,3,42,59,105 
,3,43,60,105 ,3,44,61,105 ,3,45,62,105 ,3,46,63,105 
,3,47,64,105 ,3,48,65,105 ,3,49,66,105 ,3,50,67,105 
,3,51,68,105 ,3,52,69,105 ,3,53,54,81 ,3,54,55,82 
,3,55,56,83 ,3,56,57,84 ,3,57,58,85 ,3,58,59,86 
,3,59,60,87 ,3,60,61,88 ,3,61,62,89 ,3,62,63,90 
,3,63,64,91 ,3,64,65,92 ,3,65,66,93 ,3,66,67,94 
,3,67,68,95 ,3,68,69,96 ,3,69,71,97 ,3,70,71,105 
,3,71,111,72 ,2,72,98 ,4,72,112,74,113 ,5,73,78,114,99,100 
,3,74,76,101 ,2,74,75 ,5,75,115,18,35,19 ,4,75,116,20,117 
,6,76,118,21,35,22,102 ,6,76,120,23,35,24,103 ,5,76,121,25,77,104 
,8,77,122,111,112,78,123,113,105 ,5,77,124,21,35,22 ,5,77,125,23,35,24 
,5,77,126,18,35,19 ,3,78,26,107 ,3,78,27,127 ,3,78,28,128 
,3,78,29,129 ,3,78,30,130 ,2,79,31 ,2,79,32 ,4,80,79,36,80 
,1,80 ,7,81,106,1,107,108,37,81 ,1,81 ,11,82,106,2,107,109,38,2,107,110,38,82 
,1,82 ,7,83,106,3,107,108,39,83 ,1,83 ,7,84,106,4,107,108,40,84 
,1,84 ,7,85,106,5,107,108,41,85 ,1,85 ,7,86,106,6,107,108,42,86 
,1,86 ,7,87,106,7,107,108,43,87 ,1,87 ,7,88,106,8,107,108,44,88 
,1,88 ,7,89,106,9,107,108,45,89 ,1,89 ,7,90,106,10,107,108,46,90 
,1,90 ,7,91,106,11,107,108,47,91 ,1,91 ,7,92,106,12,107,108,48,92 
,1,92 ,7,93,106,13,107,108,49,93 ,1,93 ,7,94,106,14,107,108,50,94 
,1,94 ,7,95,106,15,107,108,51,95 ,1,95 ,7,96,106,16,107,108,52,96 
,1,96 ,7,97,106,17,107,108,70,97 ,1,97 ,5,98,112,73,113,98 
,1,98 ,2,99,76 ,1,99 ,2,100,75 ,1,100 ,2,101,75 ,1,101 
,3,102,119,76 ,1,102 ,3,103,119,76 ,1,103 ,3,104,119,76 
,1,104 
,0};

        private static int[] Production_row = {0

,1,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60
,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124
,128,132,136,140,144,148,152,155,160,166,170,173,179,184,191,198
,204,213,219,225,231,235,239,243,247,251,254,257,262,264,272,274
,286,288,296,298,306,308,316,318,326,328,336,338,346,348,356,358
,366,368,376,378,386,388,396,398,406,408,416,418,426,428,436,438
,444,446,449,451,454,456,459,461,465,467,471,473,477
,0};

        private static short[] Parse = {

0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3
,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4
,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6
,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7
,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9
,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10
,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12
,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13
,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14
,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14
,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15
,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15
,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17
,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17
,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18
,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18
,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19
,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20
,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21
,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21
,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22
,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23
,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23
,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24
,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24
,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25
,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26
,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26
,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27
,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27
,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28
,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29
,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29
,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30
,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30
,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32
,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33
,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,34
,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34
,34,34,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,35,35,35
,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
,35,35,35,35,35,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36
,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,37,37
,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37
,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38
,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38
,38,38,38,38,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39
,39,40,39,40,40,39,40,39,40,39,39,39,39,39,39,39,39,99,99,99
,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,98,99,98
,99,98,99,99,99,99,99,99,99,99,105,105,105,105,105,105,105,105,105,105
,105,105,105,105,105,105,105,105,105,105,104,105,104,105,104,105,105,105,105,105
,105,105,105,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107
,107,107,107,106,107,106,107,106,107,107,107,107,107,107,107,107,109,109,109,109
,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,108,109,108,109
,108,109,109,109,109,109,109,109,109,1,1,1,1,1,1,1,1,1,1,1
,1,1,1,1,1,1,1,0,1,1,44,1,45,1,1,1,1,1,1,1
,1,1,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,100
,101,100,46,101,47,101,48,101,101,101,101,101,101,101,101,97,97,97,97,97
,97,97,97,97,97,97,97,97,97,97,97,97,43,97,43,42,97,42,97,42
,96,96,96,96,96,97,97,97,103,103,103,103,103,103,103,103,103,103,103,103
,103,103,103,103,103,102,103,102,0,103,0,103,41,41,41,41,41,0,103,103
,103,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,94,52,95
,0,50,95,51,95,0,49,49,49,49,49,95,95,95,93,93,93,93,93,93
,93,93,93,93,93,93,93,93,93,92,58,59,93,0,0,93,0,93,53,54
,55,56,57,0,93,93,93,91,91,91,91,91,91,91,91,91,91,91,91,91
,91,90,0,0,0,91,0,0,91,0,91,0,0,0,0,0,62,91,91,91
,89,89,89,89,89,89,89,89,89,89,89,89,89,88,63,0,0,63,89,63
,0,89,0,89,0,0,63,63,63,0,89,89,89,87,87,87,87,87,87,87
,87,87,87,87,87,86,0,0,0,0,0,87,0,0,87,0,87,0,0,0
,67,67,66,87,87,87,85,85,85,85,85,85,85,85,85,85,85,84,67,0
,0,67,0,67,85,0,0,85,0,85,67,67,67,65,64,0,85,85,85,83
,83,83,83,83,83,83,83,83,83,82,0,65,0,0,65,0,65,83,0,0
,83,0,83,65,65,65,0,0,0,83,83,83,81,81,81,81,81,81,81,81
,81,80,0,0,61,0,0,61,0,61,81,0,0,81,0,81,60,60,61,0
,0,0,81,81,81,79,79,79,79,79,79,79,79,78,0,0,0,0,0,0
,0,0,0,79,0,0,79,0,79,0,0,0,0,0,0,79,79,79,77,77
,77,77,77,77,77,76,0,0,0,0,0,0,0,0,0,0,77,0,0,77
,0,77,0,0,0,0,0,0,77,77,77,75,75,75,75,75,75,74,0,0
,0,0,0,0,0,0,0,0,0,75,0,0,75,0,75,73,73,73,73,73
,72,75,75,75,0,0,0,0,0,0,0,0,0,73,0,0,73,0,73,71
,71,71,71,70,0,73,73,73,0,0,0,0,0,0,0,0,0,71,0,0
,71,0,71,69,69,69,68,0,0,71,71,71,0,0,0,0,0,0,0,0
,0,69,0,0,69,0,69,0,0,0,0,0,0,69,69,69
};

        private static int[] Parse_row = {0

,1387,1,34,67,100,133,166,199,232,265,298,331,364,397,430,463
,496,529,562,595,628,661,694,727,760,793,826,859,892,925,958,991
,1024,1057,1090,1123,1156,1189,1222,1485,1453,1391,1420,1519,1551,1538,1744,1614
,1711,1678,1921,1897,1873,1849,1816,1783,1750,1717,1684,1651,1618,1585,1552,1519
,1453,1255,1420,1486,1288,1321,1354
,0};

        private static short[] Conflict = {

0
};

        private static int[] Conflict_row = {0


,0};

        private static short get_conditional_production(short symbol) { return (short)0; }

        private const short END_OF_SLK_INPUT_ = 33;
        private const short START_SYMBOL = 34;
        private const short START_STATE = 0;
        private const short START_CONFLICT = 110;
        private const short END_CONFLICT = 110;
        private const short START_ACTION = 105;
        private const short END_ACTION = 131;
        private const short TOTAL_CONFLICTS = 0;

        internal const int NOT_A_SYMBOL = 0;
        internal const int NONTERMINAL_SYMBOL = 1;
        internal const int TERMINAL_SYMBOL = 2;
        internal const int ACTION_SYMBOL = 3;

        internal static short[]
        GetProductionArray(short production_number)
        {
            short index = (short)Production_row[production_number],
                    array_length = (short)Production[index],
                    new_index = 0;
            short[] productionArray = new short[18];

            while (array_length-- >= 0) {
                productionArray[new_index++] = Production[index++];
            }
            return productionArray;
        }

        internal static int GetSymbolType(short symbol)
        {
            int symbol_type = NOT_A_SYMBOL;

            if (symbol >= START_ACTION && symbol < END_ACTION) {
                symbol_type = ACTION_SYMBOL;
            } else if (symbol >= START_SYMBOL) {
                symbol_type = NONTERMINAL_SYMBOL;
            } else if (symbol > 0) {
                symbol_type = TERMINAL_SYMBOL;
            }
            return symbol_type;
        }

        internal static bool IsNonterminal(short symbol)
        {
            return (symbol >= START_SYMBOL && symbol < START_ACTION);
        }

        internal static bool IsTerminal(short symbol)
        {
            return (symbol > 0 && symbol < START_SYMBOL);
        }

        internal static bool IsAction(short symbol)
        {
            return (symbol >= START_ACTION && symbol < END_ACTION);
        }

        internal static short GetTerminalIndex(short token)
        {
            return (token);
        }

        internal static short
        get_production(short conflict_number,
                         DslToken tokens)
        {
            short entry = 0;
            int index, level;

            if (conflict_number <= TOTAL_CONFLICTS) {
                entry = (short)(conflict_number + (START_CONFLICT - 1));
                level = 1;
                while (entry >= START_CONFLICT) {
                    index = Conflict_row[entry - (START_CONFLICT - 1)];
                    index += tokens.peek(level);
                    entry = Conflict[index];
                    ++level;
                }
            }

            return entry;
        }

        private static short
        get_predicted_entry(DslToken tokens,
                              short production_number,
                              short token,
                              int scan_level,
                              int depth)
        {
            return 0;
        }

        internal static void
        parse(DslAction action,
                DslToken tokens,
                DslError error,
                short start_symbol)
        {
            short rhs, lhs;
            short production_number, entry, symbol, token, new_token;
            int production_length, top, index, level;
            short[] stack = new short[512];

            top = 511;
            stack[top] = 0;
            if (start_symbol == 0) {
                start_symbol = START_SYMBOL;
            }
            if (top > 0) {
                stack[--top] = start_symbol;
            } else { error.message("DslParse: stack overflow\n"); return; }
            token = tokens.get();
            new_token = token;

            for (symbol = (stack[top] != 0 ? stack[top++] : (short)0); symbol != 0; ) {

                if (symbol >= START_ACTION) {
                    action.execute(symbol - (START_ACTION - 1));

                } else if (symbol >= START_SYMBOL) {
                    entry = 0;
                    level = 1;
                    production_number = get_conditional_production(symbol);
                    if (production_number != 0) {
                        entry = get_predicted_entry(tokens,
                                                      production_number, token,
                                                      level, 1);
                    }
                    if (entry == 0) {
                        index = Parse_row[symbol - (START_SYMBOL - 1)];
                        index += token;
                        entry = Parse[index];
                    }
                    while (entry >= START_CONFLICT) {
                        index = Conflict_row[entry - (START_CONFLICT - 1)];
                        index += tokens.peek(level);
                        entry = Conflict[index];
                        ++level;
                    }
                    if (entry != 0) {
                        index = Production_row[entry];
                        production_length = Production[index] - 1;
                        lhs = Production[++index];
                        if (lhs == symbol) {
                            action.predict(entry);
                            index += production_length;
                            for (; production_length-- > 0; --index) {
                                if (top > 0) {
                                    stack[--top] = Production[index];
                                } else { error.message("DslParse: stack overflow\n"); return; }
                            }
                        } else {
                            new_token = error.no_entry(symbol, token, level - 1);
                        }
                    } else {                                       // no table entry
                        new_token = error.no_entry(symbol, token, level - 1);
                    }
                } else if (symbol > 0) {
                    if (symbol == token) {
                        token = tokens.get();
                        new_token = token;
                    } else {
                        new_token = error.mismatch(symbol, token);
                    }
                } else {
                    error.message("\n parser error: symbol value 0\n");
                }
                if (token != new_token) {
                    if (new_token != 0) {
                        token = new_token;
                    }
                    if (token != END_OF_SLK_INPUT_) {
                        continue;
                    }
                }
                symbol = (stack[top] != 0 ? stack[top++] : (short)0);
            }
            if (token != END_OF_SLK_INPUT_) {
                error.input_left();
            }
        }



    };


}
#endif