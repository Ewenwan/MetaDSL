TRANSLATION_UNIT :
    { DECLARATION } __FINISHPARSE

DECLARATION :
    { DECLARATION_SPECIFIER }+ FUNCTION_OR_DECLARATION
    CONSTRUCTOR 
    TYPEDEF { DECLARATION_SPECIFIER }+ [ INIT_DECLARATOR_LIST2 ] ;
    ACCESS_SPECIFIER :
    USING QUALIFIED_TYPE ;

CONSTRUCTOR : 
    [ TYPEDEF_NAME :: ] [ ~ ] TYPEDEF_NAME ( [ PARAMETER_TYPE_LIST ] ) [ BASE_LIST ] MORE_CONSTRUCTOR
    TAG_NAME ( [ PARAMETER_TYPE_LIST ] ) MORE_CONSTRUCTOR 

MORE_CONSTRUCTOR :
    COMPOUND_STATEMENT
    ;

BASE_LIST :
    : QUALIFIED_ID_OR_TYPE ( [ EXPRESSION ] ) { , QUALIFIED_ID_OR_TYPE ( [ EXPRESSION ] ) }

FUNCTION_OR_DECLARATION :
    DECLARATOR MORE_FUNCTION_OR_DECLARATION
    ;

MORE_FUNCTION_OR_DECLARATION :
    COMPOUND_STATEMENT
    [ = INITIALIZER ] { , INIT_DECLARATOR } ;

DECLARATION_SPECIFIER :
    STORAGE_CLASS_SPECIFIER 
    TYPE_SPECIFIER
    TYPE_QUALIFIER 
    ACCESS_SPECIFIER
    FUNCTION_SPECIFIER
    FRIEND

STORAGE_CLASS_SPECIFIER :
    AUTO
    REGISTER
    STATIC
    EXTERN 
    MUTABLE

FUNCTION_SPECIFIER :
    INLINE
    VIRTUAL
    EXPLICIT

TYPE_SPECIFIER :
    VOID
    CHAR
    SHORT
    INT
    LONG
    FLOAT
    DOUBLE
    SIGNED
    UNSIGNED
    TYPEDEF_NAME [ :: TYPEDEF_NAME ]
    STRUCT_OR_UNION_SPECIFIER 
    ENUM_SPECIFIER

TYPE_QUALIFIER :
    CONST
    VOLATILE

ACCESS_SPECIFIER :
    PRIVATE
    PROTECTED
    PUBLIC

STRUCT_OR_UNION_SPECIFIER :
    STRUCT_OR_UNION ID_OR_TAGNAME [ [ BASE_CLAUSE ] \{ { DECLARATION } \} ]
    STRUCT_OR_UNION \{ { DECLARATION } \}
    CLASS ID_OR_TYPENAME [ [ BASE_CLAUSE ] \{ { DECLARATION } \} ]

STRUCT_OR_UNION :
    STRUCT
    UNION

QUALIFIED_ID :
    [ { ID_OR_TYPENAME :: }+ { * } ] IDENTIFIER

QUALIFIED_ID_OR_TYPE :
    { ID_OR_TYPENAME :: } ID_OR_TYPENAME

QUALIFIED_TYPE :
    { ID_OR_TYPENAME :: } TYPEDEF_NAME

ID_OR_TYPENAME :
    TYPEDEF_NAME
    __SETTYPEDEFNAME IDENTIFIER

ID_OR_TAGNAME :
    TAG_NAME
    __SETTAGNAME IDENTIFIER

BASE_CLAUSE :
    : [ ACCESS_SPECIFIER ] QUALIFIED_ID_OR_TYPE { , [ ACCESS_SPECIFIER ] QUALIFIED_ID_OR_TYPE }

INIT_DECLARATOR :
    DECLARATOR [ : CONSTANT_EXPRESSION ] [ = INITIALIZER ]
    : CONSTANT_EXPRESSION

INIT_DECLARATOR_LIST2 :
    INIT_DECLARATOR2 { , INIT_DECLARATOR2 }

INIT_DECLARATOR2 :
    DECLARATOR __SETTYPEDEFNAME [ = INITIALIZER ]

SPECIFIER_QUALIFIER :
    TYPE_SPECIFIER 
    TYPE_QUALIFIER 

ENUM_SPECIFIER :
    ENUM \{ ENUMERATOR_LIST \}
    ENUM IDENTIFIER [ \{ ENUMERATOR_LIST \} ]

ENUMERATOR_LIST :
    ENUMERATOR { , ENUMERATOR }

ENUMERATOR :
    IDENTIFIER __SETENUMNAME [ = CONSTANT_EXPRESSION ]
    ENUM_NAME [ = CONSTANT_EXPRESSION ]

DECLARATOR :
    [ POINTER ] DIRECT_DECLARATOR

DIRECT_DECLARATOR :
    QUALIFIED_ID MORE_DIRECT_DECLARATOR
    ( DECLARATOR ) MORE_DIRECT_DECLARATOR

MORE_DIRECT_DECLARATOR :
    \[ [ CONSTANT_EXPRESSION ] \] MORE_DIRECT_DECLARATOR
    __NEWSCOPE ( PARAMETER_TYPE_LIST ) __RELEASESCOPE MORE_DIRECT_DECLARATOR
    ( EXPRESSION ) MORE_DIRECT_DECLARATOR
    ( ) MORE_DIRECT_DECLARATOR
    _EPSILON_

POINTER :
    * [ TYPE_QUALIFIER ] [ POINTER ]
    & 

PARAMETER_TYPE_LIST :
    PARAMETER_DECLARATION { , PARAMETER_DECLARATION } [ , ... ]

PARAMETER_DECLARATION :
    { DECLARATION_SPECIFIER }+ [ DECLARATOR_OR_ABSTRACT_DECLARATOR ]

DECLARATOR_OR_ABSTRACT_DECLARATOR :
    DIRECT_DECLARATOR_OR_DIRECT_ABSTRACT_DECLARATOR
    POINTER [ DIRECT_DECLARATOR_OR_DIRECT_ABSTRACT_DECLARATOR ]

DIRECT_DECLARATOR_OR_DIRECT_ABSTRACT_DECLARATOR :
    QUALIFIED_ID MORE_DD_OR_DAD
    ( DECLARATOR_OR_ABSTRACT_DECLARATOR ) MORE_DD_OR_DAD
    \[ [ CONSTANT_EXPRESSION ] \] MORE_DD_OR_DAD
    ( [ PARAMETER_TYPE_LIST ] ) MORE_DD_OR_DAD

MORE_DD_OR_DAD :
    \[ [ CONSTANT_EXPRESSION ] \] MORE_DD_OR_DAD
    ( PARAMETER_TYPE_LIST ) MORE_DD_OR_DAD
    ( EXPRESSION ) MORE_DD_OR_DAD
    ( ) MORE_DD_OR_DAD
    _EPSILON_

INITIALIZER :
    ASSIGNMENT_EXPRESSION
    \{ INITIALIZER_LIST [ , ] \}

INITIALIZER_LIST :
    INITIALIZER { , INITIALIZER }

TYPE_NAME :
    { SPECIFIER_QUALIFIER }+ [ ABSTRACT_DECLARATOR ]

ABSTRACT_DECLARATOR :
    POINTER [ DIRECT_ABSTRACT_DECLARATOR ]
    DIRECT_ABSTRACT_DECLARATOR

DIRECT_ABSTRACT_DECLARATOR :
    ( ABSTRACT_DECLARATOR ) MORE_DIRECT_ABSTRACT_DECLARATOR
    \[ [ CONSTANT_EXPRESSION ] \] MORE_DIRECT_ABSTRACT_DECLARATOR
    ( [ PARAMETER_TYPE_LIST ] ) MORE_DIRECT_ABSTRACT_DECLARATOR

MORE_DIRECT_ABSTRACT_DECLARATOR :
    \[ [ CONSTANT_EXPRESSION ] \] MORE_DIRECT_ABSTRACT_DECLARATOR
    ( [ PARAMETER_TYPE_LIST ] ) MORE_DIRECT_ABSTRACT_DECLARATOR
    _EPSILON_

STATEMENT :
    LABELED_STATEMENT
    EXPRESSION_STATEMENT
    COMPOUND_STATEMENT
    SELECTION_STATEMENT
    ITERATION_STATEMENT
    JUMP_STATEMENT
    DECLARATION 

LABELED_STATEMENT :
    IDENTIFIER : STATEMENT
    CASE CONSTANT_EXPRESSION : STATEMENT
    DEFAULT : STATEMENT

EXPRESSION_STATEMENT :
    [ EXPRESSION ] ;

COMPOUND_STATEMENT :
    __NEWSCOPE \{ { STATEMENT } \} __RELEASESCOPE

SELECTION_STATEMENT :
    IF ( EXPRESSION ) STATEMENT MORE_IF
    SWITCH ( EXPRESSION ) STATEMENT

MORE_IF :!
    ELSE STATEMENT
    _EPSILON_

ITERATION_STATEMENT :
    WHILE ( EXPRESSION ) STATEMENT
    DO STATEMENT WHILE ( EXPRESSION ) ;
    FOR ( [ EXPRESSION ] ; [ EXPRESSION ] ; [ EXPRESSION ] ) STATEMENT

JUMP_STATEMENT :
    GOTO IDENTIFIER ;
    CONTINUE ;
    BREAK ;
    RETURN [ EXPRESSION ] ;

EXPRESSION :
    ASSIGNMENT_EXPRESSION { , ASSIGNMENT_EXPRESSION }

/* -----------------------------------------------------------------------
   USE SEMANTIC CHECK FOR LVALUE INSTEAD OF THE FOLLOWING PRODUCTION:
        UNARY_EXPRESSION  ASSIGNMENT_OPERATOR  ASSIGNMENT_EXPRESSION
----------------------------------------------------------------------- */

ASSIGNMENT_EXPRESSION :
    CONDITIONAL_EXPRESSION [ ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION ]

ASSIGNMENT_OPERATOR :
    =
    *=
    /=
    %=
    +=
    -=
    <<=
    >>=
    &=
    ^=
    |=

CONDITIONAL_EXPRESSION :
    LOGICAL_OR_EXPRESSION [ ? EXPRESSION : CONDITIONAL_EXPRESSION ]

LOGICAL_OR_EXPRESSION :
    LOGICAL_AND_EXPRESSION { || LOGICAL_AND_EXPRESSION }

LOGICAL_AND_EXPRESSION :
    INCLUSIVE_OR_EXPRESSION { && INCLUSIVE_OR_EXPRESSION }

INCLUSIVE_OR_EXPRESSION :
    EXCLUSIVE_OR_EXPRESSION { | EXCLUSIVE_OR_EXPRESSION }

EXCLUSIVE_OR_EXPRESSION :
    AND_EXPRESSION { ^ AND_EXPRESSION }

AND_EXPRESSION :
    EQUALITY_EXPRESSION { & EQUALITY_EXPRESSION }

EQUALITY_EXPRESSION :
    RELATIONAL_EXPRESSION { EQUALITY_OP RELATIONAL_EXPRESSION }

EQUALITY_OP :
    ==
    !=

RELATIONAL_EXPRESSION :
    SHIFT_EXPRESSION { RELATIONAL_OP SHIFT_EXPRESSION }

RELATIONAL_OP :
    <
    >
    <=
    >=

SHIFT_EXPRESSION :
    ADDITIVE_EXPRESSION { SHIFT_OP ADDITIVE_EXPRESSION }

SHIFT_OP :
    <<
    >>

ADDITIVE_EXPRESSION :
    MULTIPLICITIVE_EXPRESSION { ADDITIVE_OP MULTIPLICITIVE_EXPRESSION }

ADDITIVE_OP :
    +
    -

MULTIPLICITIVE_EXPRESSION :
    CAST_EXPRESSION { MULTIPLICITIVE_OP CAST_EXPRESSION }

MULTIPLICITIVE_OP :
    *
    /
    %

CAST_EXPRESSION :
    UNARY_EXPRESSION
    ( TYPE_NAME ) CAST_EXPRESSION

UNARY_EXPRESSION :
    POSTFIX_EXPRESSION
    ++ UNARY_EXPRESSION
    -- UNARY_EXPRESSION
    UNARY_OPERATOR CAST_EXPRESSION
    SIZEOF UNARY_EXPRESSION
    SIZEOF ( TYPE_NAME )
    NEW TYPEDEF_NAME [ :: TYPEDEF_NAME ] ( [ ARGUMENT_EXPRESSION_LIST ] ) 
    NEW ( TYPE_NAME )
    DELETE CAST_EXPRESSION
    DELETE \[ \] CAST_EXPRESSION

UNARY_OPERATOR :
    &
    *
    +
    -
    ~
    !

POSTFIX_EXPRESSION :
    PRIMARY_EXPRESSION MORE_POSTFIX_EXPRESSION

MORE_POSTFIX_EXPRESSION :
    \[ EXPRESSION \] MORE_POSTFIX_EXPRESSION
    ( [ ARGUMENT_EXPRESSION_LIST ] ) MORE_POSTFIX_EXPRESSION
    . IDENTIFIER MORE_POSTFIX_EXPRESSION
    .* IDENTIFIER MORE_POSTFIX_EXPRESSION
    -> IDENTIFIER MORE_POSTFIX_EXPRESSION
    ->* IDENTIFIER MORE_POSTFIX_EXPRESSION
    ++ MORE_POSTFIX_EXPRESSION
    -- MORE_POSTFIX_EXPRESSION
    _EPSILON_

PRIMARY_EXPRESSION :
    QUALIFIED_ID
    CONSTANT
    { STRING }+
    ( EXPRESSION )

ARGUMENT_EXPRESSION_LIST :
    ASSIGNMENT_EXPRESSION { , ASSIGNMENT_EXPRESSION }

CONSTANT :
    INTEGER_CONSTANT
    CHARACTER_CONSTANT
    FLOATING_CONSTANT
    ENUMERATION_CONSTANT
    ENUM_NAME 

CONSTANT_EXPRESSION :
    MUL_EXPRESSION { ADDITIVE_OP MUL_EXPRESSION }

MUL_EXPRESSION :
    UNARY_EXPR { MULTIPLICITIVE_OP UNARY_EXPR }

UNARY_EXPR :
    CONSTANT
    UNARY_OP UNARY_EXPR
    ( CONSTANT_EXPRESSION ) 
    SIZEOF UNARY_EXPR
    SIZEOF ( TYPE_NAME )

UNARY_OP :
    *
    +
    -
    ~
    !
